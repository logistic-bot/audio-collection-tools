#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# mass-audio-transcoder
#
# Mass parallel Audio Transcoder ffmpeg frontend.
# Copyright 2018, Ã˜yvind Stegard <oyvind@stegard.net>
#
# Requires: Python 3, python-mutagen and a recent-ish (2017/18) ffmpeg
# command in PATH.

from audio_collection_tools import *
from audio_collection_tools.mass_audio_transcoder import *
from audio_collection_tools.generate_playlists import write_pls, write_m3u

import multiprocessing
import shutil

def get_playlist_targetpaths_map(work_units):
    """Returns map of playlist input files to list of target paths."""
    val = {}
    for wu in work_units:
        if wu.source.playlist_file:
            val.setdefault(wu.source.playlist_file, []).append(wu.targetpath)

    return val            

def write_playlist_files(work_units, destdir):
    """Write any playlist files in work unit list to destination."""
    playlist_map = get_playlist_targetpaths_map(work_units)
    for playlist_file in playlist_map:
        destdir = os.path.realpath(destdir)
        playlist_dest = os.path.join(destdir, os.path.basename(playlist_file))
        playlist_paths = [os.path.relpath(filepath, destdir) for filepath in playlist_map[playlist_file]]
        LOG.info('Writing playlist {} ..'.format(playlist_dest))
        if is_pls_playlist(playlist_file):
            write_pls(playlist_dest, playlist_paths)
        elif is_m3u_playlist(playlist_file):
            write_m3u(playlist_dest, playlist_paths, True)
        else:
            raise ApplicationError('Cannot write such playlists: {}'.format(playlist_file))

def execute_work_unit(work_unit):
    """Executes work unit, typically this function expects to be called in a sub process.

    Returns the work_unit with updated status.
    """

    if work_unit.status is not Status.READY:
        return work_unit

    source, targetpath = work_unit.source, work_unit.targetpath

    try:
        os.makedirs(os.path.dirname(targetpath), exist_ok=True)
    except Exception as e:
        LOG.warn("Failed to create target directory '{}': {}".format(os.path.dirname(targetpath), str(e)))
        work_unit.status = Status.FAILED_IO
        return work_unit

    import signal
    signal.signal(signal.SIGINT, default_sigint_handler) # handle interrupts while working

    codec = source.transcode_spec.codec

    if (codec == 'copy') or (source.filetype() == FFMPEG_CODEC_EXT[codec]
                             and not source.transcode_spec.force_transcode):
        LOG.info('copy   {}'.format(targetpath))
        try:
            shutil.copy(source.filepath, targetpath)
            work_unit.status = Status.COMPLETED
        except KeyboardInterrupt:
            work_unit.status = Status.FAILED_ABORTED
            LOG.info('Shutdown.')
        except Exception as e:
            work_unit.status = Status.FAILED_IO
            LOG.warn("Failed to copy '{}' to '{}': {}".format(source.filepath, targetpath, str(e)))
    else:
        ffmpeg_args = ffmpeg_build_args(source.filepath, targetpath, source.transcode_spec.codec,
                                        source.transcode_spec.quality,
                                        source.transcode_spec.bitrate)
        LOG.debug(ffmpeg_args)

        LOG.info('ffmpeg {}'.format(targetpath))
        try:
            with subprocess.Popen(['ffmpeg'] + ffmpeg_args, stdin=subprocess.DEVNULL,
                                  stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL) as proc:

                returncode = proc.wait()
                if returncode != 0:
                    work_unit.status = Status.FAILED_FFMPEG
                    LOG.warn("ffmpeg failed for input '{}' with code {}".format(source.filepath, returncode))
                    LOG.warn("ffmpeg command was: '{}'".format(" ".join(['ffmpeg'] + ffmpeg_args)))
                else:
                    work_unit.status = Status.COMPLETED
                    
        except KeyboardInterrupt:
            work_unit.status = Status.FAILED_ABORTED
            LOG.info('Shutdown.')
        except Exception as e:
            work_unit.status = Status.FAILED_FFMPEG
            LOG.warn("Failed to execute ffmpeg for input '{}': {}".format(source.filepath, str(e)))
            LOG.warn("ffmpeg command was: '{}'".format(" ".join(['ffmpeg'] + ffmpeg_args)))

    signal.signal(signal.SIGINT, signal.SIG_IGN) # ignore interrupts while idle

    return work_unit


import argparse
parser = argparse.ArgumentParser(
    formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    description="""Mass Parallel Audio Transcoder. Transcode any
number of playlists and audio files/dirs in parallel to a
destination directory. Requires the 'ffmpeg' command in system
path.
""",epilog="""With regard to playlists, this tool is mainly targeted at
transcoding for devices which don't understand playlists, and so a
playlist will turn into a directory with all the files directly
below, named in order with the default template.

You are free to use slashes in the templates to generate the
desired structure under the destination directory.

Supported input playlist formats: m3u, m3u8, pls.
""")

parser.add_argument('inputs', metavar='INPUT', type=str, nargs='+',
                    help="""Directory trees containing audio
                    files, audio files and/or playlists pointing
                    to audio files. Always operates recursively on
                    directories. Only processes playlists directly
                    provided as arguments.""")

parser.add_argument('destdir', metavar='DESTDIR', type=str,
                    help="""Destination root directory. Paths and
                    files under this directory will be generated
                    based on templates with data from audio file
                    tags and playlist names.""")

parser.add_argument('--help-templates', action='store_true',
                    dest='help_templates', help="""Show help for templates""")

parser.add_argument('-t', '--template', type=str, dest='template',
                    help="""Select naming template for audio files that
                    are not part of playlists.""",
                    default=DEFAULT_TEMPLATE)

parser.add_argument('-p', '--playlist-template', type=str,
                    dest='playlist_template', help="""Select
                    naming template for files that are part of
                    playlists.""",
                    default=DEFAULT_TEMPLATE_PLAYLIST)

parser.add_argument('-d', '--dry', action='store_true',
                    dest='dry', help="""Dry run, only show input
                    files and targets, do not actually do any
                    transcoding.""")

parser.add_argument('-f', '--force-transcode',
                    action='store_true', dest='force_transcode',
                    help="""Force transcoding, even if source file
                    is already in the same format as target file.
                    Useful if lowering quality for smaller file sizes.""")

parser.add_argument('-o', '--overwrite', action='store_true',
                    dest='overwrite', help="""Overwrite existing
                    files at destination paths.""", default=False)

parser.add_argument('-c', '--codec', type=str, default='mp3', help="""
                    Select audio codec. Use 'copy' to transfer without transcoding.""",
                    choices=FFMPEG_CODEC_OPTS)

quality_options = parser.add_mutually_exclusive_group(required=False)
quality_options.add_argument('-q', '--quality', dest='quality', help=
                             """Set encoding quality, range and default value depends on chosen
                             codec, see ffmpeg docs.""", type=int)

quality_options.add_argument('-b', '--bitrate', dest='bitrate', help=
                    """Set encoding bitrate i kbit/s, range and default value depends on
                    chosen codec, see ffmpeg docs.""", type=int)

parser.add_argument('-x', '--debug', dest='debug',
                    action='store_true', help="""Enable debug
                    logging.""", default=False)

parser.add_argument('-v', '--version', action='version', version=VERSION)

args = parser.parse_args()

if args.help_templates:
    doc = """Templates are used for naming transcoded target files automatically.

    One template is used for audio files that are not part of any
    playlist, and another one for playlists. Template values should
    never include file extension, which is handled automatically and
    depends on the target format/codec.

    Documentation from the template expansion function follows.

    """ + expand_template.__doc__

    doc = "\n".join([line.strip() for line in doc.split('\n')])
    print(doc)
    sys.exit(0)

if args.debug:
    LOG.setLevel(logging.DEBUG)

if not os.path.isdir(args.destdir):
    LOG.error('Destination not a directory: {}'.format(args.destdir))
    sys.exit(1)

if not os.access(args.destdir, os.W_OK):
    LOG.error('Destination not a writable directory: {}'.format(args.destdir))
    sys.exit(1)

if args.force_transcode and args.codec == 'copy':
    LOG.warn('Option -f/--force-transcode has no effect with codec \'copy\'')
    
LOG.info('Using ffmpeg version {}'.format(ffmpeg_check_version()))

transcode_spec = TranscodeSpec(args.codec, args.force_transcode, args.quality, args.bitrate)

sources = []
for inputfile in args.inputs:
    LOG.info("Scanning input {} ..".format(inputfile))
    if is_playlist(inputfile):
        paths = get_audiofile_paths_from_playlist(inputfile)
        plsources = [Source(path, transcode_spec, inputfile, n, len(paths)) for n, path in enumerate(paths, 1)]
        sources.extend(plsources)
    else:
        paths = get_audiofile_paths(inputfile)
        sources.extend([Source(path, transcode_spec) for path in paths])

for n, source in enumerate(sources, 1):
    source.filenumber = n
    source.totalfiles = len(sources)

if len(sources) == 0:
    LOG.info('No input audio files found, nothing to do, goodbye.')
    sys.exit(0)

LOG.info('Sources provided a total of {} audio files'.format(len(sources)))
LOG.info('Preparing target paths ..')
work_units = prepare_work_units(sources, args.destdir,
                                args.template, args.playlist_template, args.overwrite)

if args.dry:
    LOG.info('Dry run only, target paths and status:')
    for work_unit in work_units:
        print("{}, {}".format(work_unit.targetpath, work_unit.status))
    sys.exit(0)

LOG.info('Starting work ..')

def pool_worker_init():
    import signal
    global default_sigint_handler
    default_sigint_handler = signal.signal(signal.SIGINT, signal.SIG_IGN)

    multiprocessing.current_process().name = re.sub('^[a-zA-Z]+', 'Worker',
                                                    multiprocessing.current_process().name)
    LOG.debug('init {}'.format(multiprocessing.current_process().name))

with multiprocessing.Pool(multiprocessing.cpu_count(), pool_worker_init) as pool:
    try:
        work_units = pool.map_async(execute_work_unit, work_units).get()
        failed = sum(map(lambda wu: 1 if wu.status.is_failed() else 0, work_units))
        skipped = sum(map(lambda wu: 1 if wu.status.is_skipped() else 0, work_units))
        completed = sum(map(lambda wu: 1 if wu.status.is_completed() else 0, work_units))
        LOG.info('{} transcodings completed, {} failed, {} skipped.'.format(completed, failed, skipped))

    except KeyboardInterrupt:
        LOG.warn('User interrupt')
        sys.exit(130)

# Write any playlist files
write_playlist_files(work_units, args.destdir)

LOG.info('Finished.')
